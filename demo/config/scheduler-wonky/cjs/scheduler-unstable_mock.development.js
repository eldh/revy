/** @license React vundefined
 * scheduler-unstable_mock.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== 'production') {
  (function() {
    'use strict';

    Object.defineProperty(exports, '__esModule', { value: true });

    var enableSchedulerDebugging = false;

    var currentTime = 0;
    var scheduledCallback = null;
    var scheduledCallbackExpiration = -1;
    var yieldedValues = null;
    var expectedNumberOfYields = -1;
    var didStop = false;
    var isFlushing = false;

    function requestHostCallback(callback, expiration) {
      scheduledCallback = callback;
      scheduledCallbackExpiration = expiration;
    }

    function cancelHostCallback() {
      scheduledCallback = null;
      scheduledCallbackExpiration = -1;
    }

    function shouldYieldToHost() {
      if (
        (expectedNumberOfYields !== -1 &&
          yieldedValues !== null &&
          yieldedValues.length >= expectedNumberOfYields) ||
        (scheduledCallbackExpiration !== -1 &&
          scheduledCallbackExpiration <= currentTime)
      ) {
        // We yielded at least as many values as expected. Stop flushing.
        didStop = true;
        return true;
      }
      return false;
    }

    function getCurrentTime() {
      return currentTime;
    }

    function forceFrameRate() {
      // No-op
    }

    // Should only be used via an assertion helper that inspects the yielded values.
    function unstable_flushNumberOfYields(count) {
      if (isFlushing) {
        throw new Error('Already flushing work.');
      }
      expectedNumberOfYields = count;
      isFlushing = true;
      try {
        while (scheduledCallback !== null && !didStop) {
          var cb = scheduledCallback;
          scheduledCallback = null;
          var didTimeout =
            scheduledCallbackExpiration !== -1 &&
            scheduledCallbackExpiration <= currentTime;
          cb(didTimeout);
        }
      } finally {
        expectedNumberOfYields = -1;
        didStop = false;
        isFlushing = false;
      }
    }

    function unstable_flushExpired() {
      if (isFlushing) {
        throw new Error('Already flushing work.');
      }
      if (scheduledCallback !== null) {
        var cb = scheduledCallback;
        scheduledCallback = null;
        isFlushing = true;
        try {
          cb(true);
        } finally {
          isFlushing = false;
        }
      }
    }

    function unstable_flushWithoutYielding() {
      if (isFlushing) {
        throw new Error('Already flushing work.');
      }
      isFlushing = true;
      try {
        if (scheduledCallback === null) {
          return false;
        }
        while (scheduledCallback !== null) {
          var cb = scheduledCallback;
          scheduledCallback = null;
          var didTimeout =
            scheduledCallbackExpiration !== -1 &&
            scheduledCallbackExpiration <= currentTime;
          cb(didTimeout);
        }
        return true;
      } finally {
        expectedNumberOfYields = -1;
        didStop = false;
        isFlushing = false;
      }
    }

    function unstable_clearYields() {
      if (yieldedValues === null) {
        return [];
      }
      var values = yieldedValues;
      yieldedValues = null;
      return values;
    }

    function flushAll() {
      if (yieldedValues !== null) {
        throw new Error(
          'Log is not empty. Assert on the log of yielded values before ' +
            'flushing additional work.'
        );
      }
      unstable_flushWithoutYielding();
      if (yieldedValues !== null) {
        throw new Error(
          'While flushing work, something yielded a value. Use an ' +
            'assertion helper to assert on the log of yielded values, e.g. ' +
            'expect(Scheduler).toFlushAndYield([...])'
        );
      }
    }

    function yieldValue(value) {
      if (yieldedValues === null) {
        yieldedValues = [value];
      } else {
        yieldedValues.push(value);
      }
    }

    function advanceTime(ms) {
      currentTime += ms;
      // If the host callback timed out, flush the expired work.
      if (
        !isFlushing &&
        scheduledCallbackExpiration !== -1 &&
        scheduledCallbackExpiration <= currentTime
      ) {
        unstable_flushExpired();
      }
    }

    /* eslint-disable no-var */

    // TODO: Use symbols?
    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5;

    // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111
    var maxSigned31BitInt = 1073741823;

    // Times out immediately
    var IMMEDIATE_PRIORITY_TIMEOUT = -1;
    // Eventually times out
    var USER_BLOCKING_PRIORITY = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000;
    // Never times out
    var IDLE_PRIORITY = maxSigned31BitInt;

    // Callbacks are stored as a circular, doubly linked list.
    var firstCallbackNode = null;

    var currentHostCallbackDidTimeout = false;
    // Pausing the scheduler is useful for debugging.
    var isSchedulerPaused = false;

    var currentPriorityLevel = NormalPriority;
    var currentEventStartTime = -1;
    var currentExpirationTime = -1;

    // This is set while performing work, to prevent re-entrancy.
    var isPerformingWork = false;

    var isHostCallbackScheduled = false;

    function scheduleHostCallbackIfNeeded() {
      if (isPerformingWork) {
        // Don't schedule work yet; wait until the next time we yield.
        return;
      }
      if (firstCallbackNode !== null) {
        // Schedule the host callback using the earliest expiration in the list.
        var expirationTime = firstCallbackNode.expirationTime;
        if (isHostCallbackScheduled) {
          // Cancel the existing host callback.
          cancelHostCallback();
        } else {
          isHostCallbackScheduled = true;
        }
        requestHostCallback(flushWork, expirationTime);
      }
    }

    function flushFirstCallback() {
      var currentlyFlushingCallback = firstCallbackNode;

      // Remove the node from the list before calling the callback. That way the
      // list is in a consistent state even if the callback throws.
      var next = firstCallbackNode.next;
      if (firstCallbackNode === next) {
        // This is the last callback in the list.
        firstCallbackNode = null;
        next = null;
      } else {
        var lastCallbackNode = firstCallbackNode.previous;
        firstCallbackNode = lastCallbackNode.next = next;
        next.previous = lastCallbackNode;
      }

      currentlyFlushingCallback.next = currentlyFlushingCallback.previous = null;

      // Now it's safe to call the callback.
      var callback = currentlyFlushingCallback.callback;
      var expirationTime = currentlyFlushingCallback.expirationTime;
      var priorityLevel = currentlyFlushingCallback.priorityLevel;
      var previousPriorityLevel = currentPriorityLevel;
      var previousExpirationTime = currentExpirationTime;
      currentPriorityLevel = priorityLevel;
      currentExpirationTime = expirationTime;
      var continuationCallback;
      try {
        var didUserCallbackTimeout =
          currentHostCallbackDidTimeout ||
          // Immediate priority callbacks are always called as if they timed out
          priorityLevel === ImmediatePriority;
        continuationCallback = callback(didUserCallbackTimeout);
      } catch (error) {
        throw error;
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentExpirationTime = previousExpirationTime;
      }

      // A callback may return a continuation. The continuation should be scheduled
      // with the same priority and expiration as the just-finished callback.
      if (typeof continuationCallback === 'function') {
        var continuationNode = {
          callback: continuationCallback,
          priorityLevel: priorityLevel,
          expirationTime: expirationTime,
          next: null,
          previous: null,
        };

        // Insert the new callback into the list, sorted by its expiration. This is
        // almost the same as the code in `scheduleCallback`, except the callback
        // is inserted into the list *before* callbacks of equal expiration instead
        // of after.
        if (firstCallbackNode === null) {
          // This is the first callback in the list.
          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
        } else {
          var nextAfterContinuation = null;
          var node = firstCallbackNode;
          do {
            if (node.expirationTime >= expirationTime) {
              // This callback expires at or after the continuation. We will insert
              // the continuation *before* this callback.
              nextAfterContinuation = node;
              break;
            }
            node = node.next;
          } while (node !== firstCallbackNode);

          if (nextAfterContinuation === null) {
            // No equal or lower priority callback was found, which means the new
            // callback is the lowest priority callback in the list.
            nextAfterContinuation = firstCallbackNode;
          } else if (nextAfterContinuation === firstCallbackNode) {
            // The new callback is the highest priority callback in the list.
            firstCallbackNode = continuationNode;
            scheduleHostCallbackIfNeeded();
          }

          var previous = nextAfterContinuation.previous;
          previous.next = nextAfterContinuation.previous = continuationNode;
          continuationNode.next = nextAfterContinuation;
          continuationNode.previous = previous;
        }
      }
    }

    function flushWork(didUserCallbackTimeout) {
      // Exit right away if we're currently paused
      if (enableSchedulerDebugging && isSchedulerPaused) {
        return;
      }

      // We'll need a new host callback the next time work is scheduled.
      isHostCallbackScheduled = false;

      isPerformingWork = true;
      var previousDidTimeout = currentHostCallbackDidTimeout;
      currentHostCallbackDidTimeout = didUserCallbackTimeout;
      try {
        if (didUserCallbackTimeout) {
          // Flush all the expired callbacks without yielding.
          while (
            firstCallbackNode !== null &&
            !(enableSchedulerDebugging && isSchedulerPaused)
          ) {
            // TODO Wrap in feature flag
            // Read the current time. Flush all the callbacks that expire at or
            // earlier than that time. Then read the current time again and repeat.
            // This optimizes for as few performance.now calls as possible.
            var currentTime = getCurrentTime();
            if (firstCallbackNode.expirationTime <= currentTime) {
              do {
                flushFirstCallback();
              } while (
                firstCallbackNode !== null &&
                firstCallbackNode.expirationTime <= currentTime &&
                !(enableSchedulerDebugging && isSchedulerPaused)
              );
              continue;
            }
            break;
          }
        } else {
          // Keep flushing callbacks until we run out of time in the frame.
          if (firstCallbackNode !== null) {
            do {
              if (enableSchedulerDebugging && isSchedulerPaused) {
                break;
              }
              flushFirstCallback();
            } while (firstCallbackNode !== null && !shouldYieldToHost());
          }
        }
      } finally {
        isPerformingWork = false;
        currentHostCallbackDidTimeout = previousDidTimeout;
        // There's still work remaining. Request another callback.
        scheduleHostCallbackIfNeeded();
      }
    }

    function unstable_runWithPriority(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
        case LowPriority:
        case IdlePriority:
          break;
        default:
          priorityLevel = NormalPriority;
      }

      var previousPriorityLevel = currentPriorityLevel;
      var previousEventStartTime = currentEventStartTime;
      currentPriorityLevel = priorityLevel;
      currentEventStartTime = getCurrentTime();

      try {
        return eventHandler();
      } catch (error) {
        // There's still work remaining. Request another callback.
        scheduleHostCallbackIfNeeded();
        throw error;
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentEventStartTime = previousEventStartTime;
      }
    }

    function unstable_next(eventHandler) {
      var priorityLevel = void 0;
      switch (currentPriorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
          // Shift down to normal priority
          priorityLevel = NormalPriority;
          break;
        default:
          // Anything lower than normal priority should remain at the current level.
          priorityLevel = currentPriorityLevel;
          break;
      }

      var previousPriorityLevel = currentPriorityLevel;
      var previousEventStartTime = currentEventStartTime;
      currentPriorityLevel = priorityLevel;
      currentEventStartTime = getCurrentTime();

      try {
        return eventHandler();
      } catch (error) {
        // There's still work remaining. Request another callback.
        scheduleHostCallbackIfNeeded();
        throw error;
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentEventStartTime = previousEventStartTime;
      }
    }

    function unstable_wrapCallback(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        // This is a fork of runWithPriority, inlined for performance.
        var previousPriorityLevel = currentPriorityLevel;
        var previousEventStartTime = currentEventStartTime;
        currentPriorityLevel = parentPriorityLevel;
        currentEventStartTime = getCurrentTime();

        try {
          return callback.apply(this, arguments);
        } catch (error) {
          // There's still work remaining. Request another callback.
          scheduleHostCallbackIfNeeded();
          throw error;
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentEventStartTime = previousEventStartTime;
        }
      };
    }

    function unstable_scheduleCallback(
      priorityLevel,
      callback,
      deprecated_options
    ) {
      var startTime =
        currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime();

      var expirationTime;
      if (
        typeof deprecated_options === 'object' &&
        deprecated_options !== null &&
        typeof deprecated_options.timeout === 'number'
      ) {
        // FIXME: Remove this branch once we lift expiration times out of React.
        expirationTime = startTime + deprecated_options.timeout;
      } else {
        switch (priorityLevel) {
          case ImmediatePriority:
            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
            break;
          case UserBlockingPriority:
            expirationTime = startTime + USER_BLOCKING_PRIORITY;
            break;
          case IdlePriority:
            expirationTime = startTime + IDLE_PRIORITY;
            break;
          case LowPriority:
            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
            break;
          case NormalPriority:
          default:
            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
        }
      }

      var newNode = {
        callback: callback,
        priorityLevel: priorityLevel,
        expirationTime: expirationTime,
        next: null,
        previous: null,
      };

      // Insert the new callback into the list, ordered first by expiration, then
      // by insertion. So the new callback is inserted after any other callback
      // with equal expiration.
      if (firstCallbackNode === null) {
        // This is the first callback in the list.
        firstCallbackNode = newNode.next = newNode.previous = newNode;
        scheduleHostCallbackIfNeeded();
      } else {
        var next = null;
        var node = firstCallbackNode;
        do {
          if (node.expirationTime > expirationTime) {
            // The new callback expires before this one.
            next = node;
            break;
          }
          node = node.next;
        } while (node !== firstCallbackNode);

        if (next === null) {
          // No callback with a later expiration was found, which means the new
          // callback has the latest expiration in the list.
          next = firstCallbackNode;
        } else if (next === firstCallbackNode) {
          // The new callback has the earliest expiration in the entire list.
          firstCallbackNode = newNode;
          scheduleHostCallbackIfNeeded();
        }

        var previous = next.previous;
        previous.next = next.previous = newNode;
        newNode.next = next;
        newNode.previous = previous;
      }

      return newNode;
    }

    function unstable_pauseExecution() {
      isSchedulerPaused = true;
    }

    function unstable_continueExecution() {
      isSchedulerPaused = false;
      if (firstCallbackNode !== null) {
        scheduleHostCallbackIfNeeded();
      }
    }

    function unstable_getFirstCallbackNode() {
      return firstCallbackNode;
    }

    function unstable_cancelCallback(callbackNode) {
      var next = callbackNode.next;
      if (next === null) {
        // Already cancelled.
        return;
      }

      if (next === callbackNode) {
        // This is the only scheduled callback. Clear the list.
        firstCallbackNode = null;
      } else {
        // Remove the callback from its position in the list.
        if (callbackNode === firstCallbackNode) {
          firstCallbackNode = next;
        }
        var previous = callbackNode.previous;
        previous.next = next;
        next.previous = previous;
      }

      callbackNode.next = callbackNode.previous = null;
    }

    function unstable_getCurrentPriorityLevel() {
      return currentPriorityLevel;
    }

    function unstable_shouldYield() {
      return (
        !currentHostCallbackDidTimeout &&
        ((firstCallbackNode !== null &&
          firstCallbackNode.expirationTime < currentExpirationTime) ||
          shouldYieldToHost())
      );
    }

    exports.unstable_flushWithoutYielding = unstable_flushWithoutYielding;
    exports.unstable_flushNumberOfYields = unstable_flushNumberOfYields;
    exports.unstable_flushExpired = unstable_flushExpired;
    exports.unstable_clearYields = unstable_clearYields;
    exports.flushAll = flushAll;
    exports.yieldValue = yieldValue;
    exports.advanceTime = advanceTime;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_next = unstable_next;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_wrapCallback = unstable_wrapCallback;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_shouldYield = unstable_shouldYield;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_now = getCurrentTime;
    exports.unstable_forceFrameRate = forceFrameRate;
  })();
}
